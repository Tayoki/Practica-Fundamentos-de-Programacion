#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <string.h>

typedef struct {
    double x, y;
    int label; 
} Point;

double rand_uniform() {
    return (double)rand() / (double)RAND_MAX;
}

double rand_normal(double mu, double sigma) {
    static int have = 0;
    static double z1;
    if (have) {
        have = 0;
        return mu + sigma * z1;
    }
    double u1, u2, s;
    do {
        u1 = rand_uniform();
        u2 = rand_uniform();
    } while (u1 <= 1e-12);
    double r = sqrt(-2.0 * log(u1));
    double theta = 2.0 * M_PI * u2;
    double z0 = r * cos(theta);
    z1 = r * sin(theta);
    have = 1;
    return mu + sigma * z0;
}

double dist_euclid(Point a, Point b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
}

typedef struct {
    double d;
    int label;
} DistLabel;

int cmp_distlabel(const void *a, const void *b) {
    DistLabel const *A = a;
    DistLabel const *B = b;
    if (A->d < B->d) return -1;
    else if (A->d > B->d) return 1;
    return 0;
}

int knn_predict(Point *train, int ntrain, Point p, int k) {
    DistLabel *arr = (DistLabel*)malloc(sizeof(DistLabel) * ntrain);
    if (!arr) { fprintf(stderr, "malloc failed\n"); exit(1); }
    for (int i = 0; i < ntrain; ++i) {
        arr[i].d = dist_euclid(train[i], p);
        arr[i].label = train[i].label;
    }
    qsort(arr, ntrain, sizeof(DistLabel), cmp_distlabel);
    int votes0 = 0, votes1 = 0;
    for (int i = 0; i < k && i < ntrain; ++i) {
        if (arr[i].label == 0) votes0++;
        else votes1++;
    }
    free(arr);
    return (votes1 > votes0) ? 1 : 0; 
}

double evaluate_knn(Point *train, int ntrain, Point *test, int ntest, int k) {
    int correct = 0;
    for (int i = 0; i < ntest; ++i) {
        int pred = knn_predict(train, ntrain, test[i], k);
        if (pred == test[i].label) correct++;
    }
    return 100.0 * (double)correct / (double)ntest;
}

typedef struct {
    double A, B, C;
    int vertical; 
    double x_const; 
} Line;

Line line_from_two_points(Point p1, Point p2) {
    Line L;
    double dx = p2.x - p1.x;
    double dy = p2.y - p1.y;
    if (fabs(dx) < 1e-12) {
        L.vertical = 1;
        L.x_const = p1.x;
        L.A = 1; L.B = 0; L.C = -p1.x;
    } else {
        L.vertical = 0;
        double m = dy / dx; 
        double b = p1.y - m * p1.x; 
        
        L.A = m;
        L.B = -1;
        L.C = b;
    }
   
    double norm = sqrt(L.A*L.A + L.B*L.B);
    if (norm > 0) {
        L.A /= norm; L.B /= norm; L.C /= norm;
    }
    return L;
}


double point_line_distance(Line L, Point p) {
    if (L.vertical) {
        return fabs(p.x - L.x_const);
    } else {
        return fabs(L.A * p.x + L.B * p.y + L.C); 
    }
}


Line least_squares_line(Point *pts, int n) {
    Line L;
    if (n <= 1) {
        /* degenerate */
        L.vertical = 1;
        L.x_const = (n == 1) ? pts[0].x : 0.0;
        L.A = 1; L.B = 0; L.C = -L.x_const;
        return L;
    }
    double sx = 0, sy = 0, sxx = 0, sxy = 0;
    for (int i = 0; i < n; ++i) {
        sx += pts[i].x;
        sy += pts[i].y;
        sxx += pts[i].x * pts[i].x;
        sxy += pts[i].x * pts[i].y;
    }
    double mx = sx / n;
    double my = sy / n;
    double varx = sxx / n - mx*mx;
    if (fabs(varx) < 1e-10) {
       
        L.vertical = 1;
        L.x_const = mx;
        L.A = 1; L.B = 0; L.C = -mx;
        return L;
    }
    double m = (sxy / n - mx * my) / varx;
    double b = my - m * mx;
    L.vertical = 0;
    L.A = m; L.B = -1; L.C = b;
    double norm = sqrt(L.A*L.A + L.B*L.B);
    if (norm > 0) { L.A /= norm; L.B /= norm; L.C /= norm; }
    return L;
}


int predict_by_line(Line l0, Line l1, Point p) {
    double d0 = point_line_distance(l0, p);
    double d1 = point_line_distance(l1, p);
    return (d1 < d0) ? 1 : 0;
}

double evaluate_line_classifier(Line l0, Line l1, Point *test, int ntest) {
    int correct = 0;
    for (int i = 0; i < ntest; ++i) {
        int pred = predict_by_line(l0, l1, test[i]);
        if (pred == test[i].label) correct++;
    }
    return 100.0 * (double)correct / (double)ntest;
}


void generate_class(Point *arr, int n, double slope, double intercept, double x_center, double x_spread, double noise_sigma, int label) {
    for (int i = 0; i < n; ++i) {
        double x = x_center + (rand_uniform() - 0.5) * x_spread;
        double y_true = slope * x + intercept;
        double y = y_true + rand_normal(0.0, noise_sigma);
        arr[i].x = x;
        arr[i].y = y;
        arr[i].label = label;
    }
}


void shuffle_points(Point *arr, int n) {
    for (int i = n-1; i > 0; --i) {
        int j = rand() % (i+1);
        Point tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

int main() {
    
    int N_class0 = 2000; 
    int N_class1 = 2000;
    double train_frac = 0.8;
    int seed = (int)time(NULL);
    srand(seed);

    printf("KNN + Recta (LS) demo en C\nSeed: %d\n", seed);
    printf("Clase0: %d puntos, Clase1: %d puntos. Train fraction: %.2f\n", N_class0, N_class1, train_frac);

   
    Point *all0 = (Point*)malloc(sizeof(Point) * N_class0);
    Point *all1 = (Point*)malloc(sizeof(Point) * N_class1);
    if (!all0 || !all1) { fprintf(stderr, "malloc failed\n"); return 1; }

   
    generate_class(all0, N_class0, 0.3, -1.0, -5.0, 6.0, 1.0, 0);
    generate_class(all1, N_class1, -0.2, 2.0, 5.0, 6.0, 1.0, 1);

  
    int train0 = (int)(N_class0 * train_frac);
    int train1 = (int)(N_class1 * train_frac);
    int test0 = N_class0 - train0;
    int test1 = N_class1 - train1;

   
    shuffle_points(all0, N_class0);
    shuffle_points(all1, N_class1);

    int ntrain = train0 + train1;
    int ntest = test0 + test1;

    Point *train = (Point*)malloc(sizeof(Point) * ntrain);
    Point *test = (Point*)malloc(sizeof(Point) * ntest);
    if (!train || !test) { fprintf(stderr, "malloc failed\n"); return 1; }

  
    for (int i = 0; i < train0; ++i) train[i] = all0[i];
    for (int i = 0; i < train1; ++i) train[train0 + i] = all1[i];

    for (int i = 0; i < test0; ++i) test[i] = all0[train0 + i];
    for (int i = 0; i < test1; ++i) test[test0 + i] = all1[train1 + i];

   
    shuffle_points(train, ntrain);
    shuffle_points(test, ntest);

    printf("Train size: %d (class0=%d, class1=%d), Test size: %d (class0=%d, class1=%d)\n",
            ntrain, train0, train1, ntest, test0, test1);

  
    int K_values[] = {1,3,5,7,9,11,13,15,17,19};
    int Kcount = sizeof(K_values)/sizeof(int);

    double best_acc = -1.0;
    int best_k = K_values[0];
    printf("\nEvaluando KNN para varios K:\n");
    for (int i = 0; i < Kcount; ++i) {
        int k = K_values[i];
        if (k > ntrain) continue;
        double acc = evaluate_knn(train, ntrain, test, ntest, k);
        printf(" K=%2d -> Accuracy: %.2f%%\n", k, acc);
        if (acc > best_acc) { best_acc = acc; best_k = k; }
    }
    printf("Mejor K encontrado: %d con Accuracy = %.2f%%\n", best_k, best_acc);


    Point *train0_pts = (Point*)malloc(sizeof(Point) * train0);
    Point *train1_pts = (Point*)malloc(sizeof(Point) * train1);
    if (!train0_pts || !train1_pts) { fprintf(stderr, "malloc failed\n"); return 1; }
    int c0count = 0, c1count = 0;
    for (int i = 0; i < ntrain; ++i) {
        if (train[i].label == 0) train0_pts[c0count++] = train[i];
        else train1_pts[c1count++] = train[i];
    }
    if (c0count != train0 || c1count != train1) {
      
    }
    Line L0 = least_squares_line(train0_pts, c0count);
    Line L1 = least_squares_line(train1_pts, c1count);

 
    printf("\nRectas ajustadas por mÃ­nimos cuadrados (usando training):\n");
    if (L0.vertical) {
        printf(" Clase 0: recta vertical x = %.6f\n", L0.x_const);
    } else {
        
        double slope0 = L0.A / 1.0;
        double intercept0 = L0.C / 1.0;
        printf(" Clase 0: y = %.6f * x + %.6f\n", slope0, intercept0);
    }
    if (L1.vertical) {
        printf(" Clase 1: recta vertical x = %.6f\n", L1.x_const);
    } else {
        double slope1 = L1.A / 1.0;
        double intercept1 = L1.C / 1.0;
        printf(" Clase 1: y = %.6f * x + %.6f\n", slope1, intercept1);
    }

   
    double acc_line = evaluate_line_classifier(L0, L1, test, ntest);
    printf("\nAccuracy con clasificaciÃ³n por distancia a rectas: %.2f%%\n", acc_line);

  
    printf("\n Obtener ecuaciÃ³n de recta a partir de 2 puntos y distancia punto->recta:\n");
    Point a = train[0], b = train[1];
    Line lab = line_from_two_points(a, b);
    if (lab.vertical) {
        printf(" Dos puntos: (%.3f, %.3f) y (%.3f, %.3f) -> recta vertical x = %.6f\n", a.x,a.y,b.x,b.y, lab.x_const);
    } else {
        double slope_ab = lab.A;
        double intercept_ab = lab.C;
        printf(" Dos puntos: (%.3f, %.3f) y (%.3f, %.3f) -> y = %.6f * x + %.6f\n", a.x,a.y,b.x,b.y, slope_ab, intercept_ab);
    }

    double d_example = point_line_distance(lab, test[0]);
    printf(" Distancia del primer punto de test (%.3f, %.3f) a esa recta = %.6f\n", test[0].x, test[0].y, d_example);


    free(all0); free(all1);
    free(train); free(test);
    free(train0_pts); free(train1_pts);

    return 0;
}
